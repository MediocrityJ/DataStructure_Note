### 双指针

#### 中等题

###### 11. 盛最多水的容器

- 在两端指针移动的过程中不断消去不可能成为最大值的状态

- 每次比较移动短板指针的指向位置

  - 如果移动长板，移动后的可盛水矩形底变短了，高只能≤原高，因此不可能面积变大
  - 如果移动短板，移动后的可盛水矩形底变短了，但高可能>=原高，因此面积可能会增大

  > 一个很明白的理解每步如何减小搜索空间的题解
  >
  > https://leetcode-cn.com/problems/container-with-most-water/solution/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu/

```java
class Solution {
    public int maxArea(int[] height) {
        int l = 0, r = height.length - 1;
        int ans = 0;
        while (l < r) {
            if (height[l] < height[r]) {
                ans = Math.max(ans, height[l] * (r - l));
                l++;
            }
            else {
                ans = Math.max(ans, height[r] * (r - l));
                r--;
            }
        }
        return ans;
    }
}
```



###### 15. 三数之和

- ```java
  class Solution {
      public List<List<Integer>> threeSum(int[] nums) {
          List<List<Integer>> ans = new ArrayList<>();
          Arrays.sort(nums);
          if (nums.length < 3) return ans;
          if (nums[0] > 0 || nums[nums.length - 1] < 0) return ans;
          for (int i = 0; i < nums.length - 2; i++) {
              int j = i + 1, k = nums.length - 1;
              int target = -nums[i];
              if (nums[i] > 0) break;
              // 下面这两个得是continue，不能是break
              if (nums[k - 1] + nums[k] < target) continue;
              if (nums[j] + nums[j + 1] > target) continue;
              if (i > 0 && nums[i] == nums[i - 1]) continue;
              while (j < k) {
                  if (nums[j] + nums[k] < target) {
                      j++;
                  } else if (nums[j] + nums[k] > target) {
                      k--;
                  } else {
                      List<Integer> tmp = new ArrayList<>();
                      tmp.add(nums[i]);
                      tmp.add(nums[j]);
                      tmp.add(nums[k]);
                      ans.add(tmp);
                      j++;
                      k--;
                      while (j < k && nums[j] == nums[j - 1]) j++;
                      while (j < k && nums[k] == nums[k + 1]) k--;
                  }
              }
          }
          return ans;
      }
  }
  ```

- 



###### 16. 最接近的三数之和

- ```java
  class Solution {
      public int threeSumClosest(int[] nums, int target) {
          Arrays.sort(nums);
          int ans = nums[0] + nums[1] + nums[2];
          for (int i = 0; i < nums.length - 2; ++ i) {
              if (i > 1 && nums[i] == nums[i - 1]) continue;
              int j = i + 1, k = nums.length - 1;
              int min = nums[i] + nums[j] + nums[j + 1];
              if (min > target) {
                  if (Math.abs(target - min) < Math.abs(target - ans)) {
                      ans = min;
                      continue;
                  }
              }
              int max = nums[i] + nums[k - 1] + nums[k];
              if (max < target) {
                  if (Math.abs(target - max) < Math.abs(target - ans)) {
                      ans = max;
                      continue;
                  }
              }
              while (j < k) {
                  int sum = nums[i] + nums[j] + nums[k];
                  if (Math.abs(target - sum) < Math.abs(target - ans)) {
                      ans = sum;
                  }
                  if (sum == target) return target;
                  else if (sum < target) {
                      j++;
                      while (j < k && nums[j] == nums[j - 1]) j++;
                  }
                  else if (sum > target) {
                      k--;
                      while (j < k && nums[k] == nums[k + 1]) k--;
                  }
              }
          }
          return ans;
      }
  }
  ```

- 



###### 18. 四数之和

- 如果当前情况下最小值大于`target`，后面的和不可能更小的
- 但如果当前情况下最大值小于`target`，后面的和是有可能更大的

- ```java
  class Solution {
      List<List<Integer>> ans = new ArrayList<List<Integer>>();
      public List<List<Integer>> fourSum(int[] nums, int target) {
          Arrays.sort(nums);
          int n = nums.length;
          if (n <= 3) return ans;
          if (nums[0] + nums[1] + nums[2] + nums[3] > target) return ans;
          if (nums[n - 1] + nums[n - 2] + nums[n - 3] + nums[n - 4] < target) return ans;
          for (int i = 0; i < n - 3; ++ i){
              if (i > 0 && nums[i] == nums[i - 1]) continue;
              if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;
              if (nums[i] + nums[n - 1] + nums[n - 2] + nums[n - 3] < target) continue;
              for (int j = i + 1; j < n - 2; ++ j){
                  if(j > i + 1 && nums[j] == nums[j - 1]) continue;
                  int t = target - nums[i] - nums[j];
                  int k = j + 1;
                  int l = n - 1;
                  // 曾经以为下面的优化语句因为上面的两个break，continue而不会有效果
                  // 应该是想错了，下面是有用的
                  if (nums[i] + nums[j] + nums[k] + nums[k + 1] > target) break;
                  if (nums[i] + nums[j] + nums[l - 1] + nums[l] < target) continue;
                  while (k < l){
                      if (nums[k] + nums[l] < t){
                          k++;
                          while(k < l && nums[k] == nums[k - 1]) k++;
                      }
                      else if (nums[k] + nums[l] > t){
                          l--;
                          while(k < l && nums[l] == nums[l + 1]) l--;
                      }
                      else{
                          List<Integer> tmp = new ArrayList<Integer>();
                          tmp.add(nums[i]);
                          tmp.add(nums[j]);
                          tmp.add(nums[k]);
                          tmp.add(nums[l]);
                          ans.add(tmp);
                          k++;
                          l--;
                          while(k < l && nums[k] == nums[k - 1]) k++;
                          while(k < l && nums[l] == nums[l + 1]) l--;
                      }
                  }
              }
          }
          return ans;
      }
  }
  ```

- 



###### 633. 平方数之和

```java
class Solution {
    public boolean judgeSquareSum(int c) {
        int i = 0;
        int j = (int)Math.sqrt(c);
        while (i <= j) {
            int sum = i * i + j * j;
            if (sum > c) j--;
            else if (sum < c) i++;
            else return true;
        }
        return false;
    }
}
```



#### 困难题

###### 42. 接雨水

- 双指针写法的一些关键
  - 在某个位置`i`处，它能存的水，取决于它左右两边的最大值中较小的一个。
  - 当我们从左往右处理到left下标时，左边的最大值left_max对它而言是可信的，但right_max对它而言是不可信的。left是从左边依次推过来的，所以左边的最大值可以确定就是left_max
  - 当我们从右往左处理到right下标时，右边的最大值right_max对它而言是可信的，但left_max对它而言是不可信的。right是从右边依次推过来的，所以右边的最大值可以确定就是right_max
  - 由于left与right中间的点还没有遍历到，因此对于left，right_max可能会更大，对于right，left_max可能会更大。
  - 对于位置`left`而言，它左边最大值一定是left_max，右边最大值“大于等于”right_max，这时候，如果`left_max<right_max`成立，那么它就知道自己能存多少水了（左边最大值一定小于右边最大值了）。无论右边将来会不会出现更大的right_max，都不影响这个结果。
  - 所以当`left_max<right_max`时，我们就希望去处理left下标，反之，我们希望去处理right下标。

```java
class Solution {
    public int trap(int[] height) {
        int l = 0, r = height.length - 1, ans = 0;
        int lMax = 0, rMax = 0;
        while (l < r) {
            lMax = Math.max(lMax, height[l]);
            rMax = Math.max(rMax, height[r]);
            if (lMax < rMax) {
                ans += lMax - height[l++];
            } else {
                ans += rMax - height[r--];
            }
        }
        return ans;
    }
}
```



### 滑动窗口

###### 228E.汇总区间

```java

```

